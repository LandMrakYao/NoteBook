## Java多线程

### 进程

程序的执行过程

持有资源(共享内存，共享文件)和线程

### 线程

线程是系统中最小的执行单元

同一进程中有多个线程

线程共享进程的资源

#### 线程的交互

**互斥、同步**

**Thread常用方法**

![QQ截图20181119165540](C:\Users\Administrator\Pictures\Camera Roll\QQ截图20181119165540.png)

#### 如何停止线程

使用退出标志

volatile boolean keeprunning = true 然后使用while语句

禁止使用stop方法，因为它无法让我们知道哪些工作还没有做，完成了什么，也没有机会做一些清理工作

#### 线程的交互

**争用条件**

当多个线程同时共享访问同一数据时，每个线程都尝试操作该数据，从而导致数据被破坏，这种现象称为争用条件。

线程的调度是通过分时和抢占完成的。

#### 线程创建的两种方式比较

1.继承Thread类然后重写run方法

2.实现Runnable接口，重写run方法。但是在创建线程的时候new Thread()要传入参数

**Runnable方式可以避免Thread方式由于java单继承特性带来的缺陷**

**Runnable的代码可以被多个线程共享，适合于多个线程处理同一资源的情况**

#### 线程的生命周期

![QQ截图20190412165841](C:\Users\Administrator\Pictures\QQ浏览器截图\QQ截图20190412165841.png)

就绪：创建了线程对象后，调用了线程的start（）方法（注意：此时线程只是进入了线程队列，等待获取CPU服务，具备了运行条件，但并不一定已经开始运行了）

终止：线程的run()方法执行完毕，或者线程调用了stop()方法，线程便进入终止状态

阻塞：一个正在执行的线程在某些情况下，由于某种原因而暂时让出了CPU资源，暂停了自己的执行，便进入了阻塞状态，如调用了sleep()方法

#### 线程的守护神——守护线程

**JAVA线程有两类**

**用户线程：运行在前台，执行具体的任务**

程序的主线程、连接网络的子线程等都是用户线程

**守护线程：运行在后台，为其他前台线程服务**

特点：一旦所有用户线程都结束运行，守护线程会随JVM一起结束工作

应用：数据库连接池中的监测线程，JVM虚拟机启动后的监测线程

最常见的守护线程：垃圾回收线程

**如何设置守护线程**

可以通过调用Thread类的setDamon(true)方法来设置当前的线程为守护线程

setDaemon必须在start()方法之前调用，否则会抛出异常

在守护线程中产生的新线程也是守护线程

不是所有的任务都可以分配给守护线程来执行，比如读写操作或者计算逻辑

**使用jstack生成线程快照**

作用：生成JVM当前时刻线程的快照

目的：帮助定位程序问题出现的原因，如长时间停顿、CPU占用率过高等

